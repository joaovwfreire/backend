A stats api call responds with data as following:
{
    "status": 200,
    "data": {
        "account": {
            "id": USER_ID,
            "name": USER_NAME
        },
        "battlePass": {
            "level": 1,
            "progress": 0
        },
        "image": null,
        "stats": {
            "all": {
                "overall": {
                    "score": 144925,
                    "scorePerMin": 24.71,
                    "scorePerMatch": 257.416,
                    "wins": 59,
                    "top3": 117,
                    "top5": 10,
                    "top6": 183,
                    "top10": 0,
                    "top12": 11,
                    "top25": 4,
                    "kills": 1352,
                    "killsPerMin": 0.231,
                    "killsPerMatch": 2.401,
                    "deaths": 504,
                    "kd": 2.683,
                    "matches": 563,
                    "winRate": 10.48,
                    "minutesPlayed": 5865,
                    "playersOutlived": 31953,
                    "lastModified": "2022-12-01T17:08:12Z"
                },
                "solo": {
                    "score": 1539,
                    "scorePerMin": 22.632,
                    "scorePerMatch": 109.929,
                    "wins": 0,
                    "top10": 0,
                    "top25": 4,
                    "kills": 10,
                    "killsPerMin": 0.147,
                    "killsPerMatch": 0.714,
                    "deaths": 14,
                    "kd": 0.714,
                    "matches": 14,
                    "winRate": 0,
                    "minutesPlayed": 68,
                    "playersOutlived": 527,
                    "lastModified": "2022-07-19T16:05:02Z"
                },
                "duo": {
                    "score": 6686,
                    "scorePerMin": 29.325,
                    "scorePerMatch": 393.294,
                    "wins": 3,
                    "top5": 10,
                    "top12": 11,
                    "kills": 88,
                    "killsPerMin": 0.386,
                    "killsPerMatch": 5.176,
                    "deaths": 14,
                    "kd": 6.286,
                    "matches": 17,
                    "winRate": 17.647,
                    "minutesPlayed": 228,
                    "playersOutlived": 1213,
                    "lastModified": "2022-07-07T14:43:28Z"
                },
                "trio": null,
                "squad": {
                    "score": 136700,
                    "scorePerMin": 24.547,
                    "scorePerMatch": 256.955,
                    "wins": 56,
                    "top3": 117,
                    "top6": 183,
                    "kills": 1254,
                    "killsPerMin": 0.225,
                    "killsPerMatch": 2.357,
                    "deaths": 476,
                    "kd": 2.634,
                    "matches": 532,
                    "winRate": 10.526,
                    "minutesPlayed": 5569,
                    "playersOutlived": 30213,
                    "lastModified": "2022-12-01T17:08:12Z"
                },
                "ltm": null
            },
            "keyboardMouse": {
                "overall": {
                    "score": 143918,
                    "scorePerMin": 24.673,
                    "scorePerMatch": 256.538,
                    "wins": 58,
                    "top3": 115,
                    "top5": 10,
                    "top6": 181,
                    "top10": 0,
                    "top12": 11,
                    "top25": 4,
                    "kills": 1350,
                    "killsPerMin": 0.231,
                    "killsPerMatch": 2.406,
                    "deaths": 503,
                    "kd": 2.684,
                    "matches": 561,
                    "winRate": 10.339,
                    "minutesPlayed": 5833,
                    "playersOutlived": 31865,
                    "lastModified": "2022-12-01T17:08:12Z"
                },
                "solo": {
                    "score": 1539,
                    "scorePerMin": 22.632,
                    "scorePerMatch": 109.929,
                    "wins": 0,
                    "top10": 0,
                    "top25": 4,
                    "kills": 10,
                    "killsPerMin": 0.147,
                    "killsPerMatch": 0.714,
                    "deaths": 14,
                    "kd": 0.714,
                    "matches": 14,
                    "winRate": 0,
                    "minutesPlayed": 68,
                    "playersOutlived": 527,
                    "lastModified": "2022-07-19T16:05:02Z"
                },
                "duo": {
                    "score": 6686,
                    "scorePerMin": 29.325,
                    "scorePerMatch": 393.294,
                    "wins": 3,
                    "top5": 10,
                    "top12": 11,
                    "kills": 88,
                    "killsPerMin": 0.386,
                    "killsPerMatch": 5.176,
                    "deaths": 14,
                    "kd": 6.286,
                    "matches": 17,
                    "winRate": 17.647,
                    "minutesPlayed": 228,
                    "playersOutlived": 1213,
                    "lastModified": "2022-07-07T14:43:28Z"
                },
                "trio": null,
                "squad": {
                    "score": 135693,
                    "scorePerMin": 24.507,
                    "scorePerMatch": 256.025,
                    "wins": 55,
                    "top3": 115,
                    "top6": 181,
                    "kills": 1252,
                    "killsPerMin": 0.226,
                    "killsPerMatch": 2.362,
                    "deaths": 475,
                    "kd": 2.636,
                    "matches": 530,
                    "winRate": 10.377,
                    "minutesPlayed": 5537,
                    "playersOutlived": 30125,
                    "lastModified": "2022-12-01T17:08:12Z"
                },
                "ltm": null
            },
            "gamepad": null,
            "touch": {
                "overall": {
                    "score": 1007,
                    "scorePerMin": 31.469,
                    "scorePerMatch": 503.5,
                    "wins": 1,
                    "top3": 2,
                    "top5": 0,
                    "top6": 2,
                    "top10": 0,
                    "top12": 0,
                    "top25": 0,
                    "kills": 2,
                    "killsPerMin": 0.062,
                    "killsPerMatch": 1,
                    "deaths": 1,
                    "kd": 2,
                    "matches": 2,
                    "winRate": 50,
                    "minutesPlayed": 32,
                    "playersOutlived": 88,
                    "lastModified": "2020-09-22T03:36:05Z"
                },
                "solo": null,
                "duo": null,
                "trio": null,
                "squad": {
                    "score": 1007,
                    "scorePerMin": 31.469,
                    "scorePerMatch": 503.5,
                    "wins": 1,
                    "top3": 2,
                    "top6": 2,
                    "kills": 2,
                    "killsPerMin": 0.062,
                    "killsPerMatch": 1,
                    "deaths": 1,
                    "kd": 2,
                    "matches": 2,
                    "winRate": 50,
                    "minutesPlayed": 32,
                    "playersOutlived": 88,
                    "lastModified": "2020-09-22T03:36:05Z"
                },
                "ltm": null
            }
        }
    }
}

If we consider this schema an object variable called response, then we can compare values stored inside it to see if the user has reached certain 
stat to complete the task.
ie.:
We can challenge a user to reach top25 4 times in 2 hours. It would require:
initial_response.data.stats.all.overall.top25 + 4 <= current_response.data.stats.all.overall.top25 && 
challengeFinshingTimestamp - challengeInitialTimestamp <= challengeDuration
This has an issue, though, as the stats only get updated at the best possible key. Meaning that, if a user reaches second place, only the top3
stat will be updated, but not top5, top6, top10, top12 or top25.

to solve it, we use the following logic:
whatever +1 in wins is equal to a +1 in top3, top5, top6, top10, top12 and top25 and so forth.
in order to make the system easier to deal with, challenges should only include 1 requirement in the top positions. The other criteria
can be freely chosen.

the actual logic would be considering points difference:

function responseForPositiveLogic = async(requirement, pointsDifference) => {
    
    if (pointsDifference >= requirement){
        return true;
    } else{
        return false
    }
}

// this doesn't get used for Fortnite, but fits games where negative value difference represent a positive outcome, such as race-track times.

function responseForNegativeLogic = async(requirement, pointsDifference) => {
    
    if (pointsDifference <= requirement){
        return true;
    } else{
        return false
    }
}

if requirements.top25 != 0 then any other top position sums
if requirements.top12 != 0 then any other top position, but top25, sums 

code:

overallObject: {
                    "score": 144925,
                    "scorePerMin": 24.71,
                    "scorePerMatch": 257.416,
                    "wins": 59,
                    "top3": 117,
                    "top5": 10,
                    "top6": 183,
                    "top10": 0,
                    "top12": 11,
                    "top25": 4,
                    "kills": 1352,
                    "killsPerMin": 0.231,
                    "killsPerMatch": 2.401,
                    "deaths": 504,
                    "kd": 2.683,
                    "matches": 563,
                    "winRate": 10.48,
                    "minutesPlayed": 5865,
                    "playersOutlived": 31953,
                    "lastModified": "2022-12-01T17:08:12Z"
                },
overallObjectWithChallenge: {
                    "score": 0,
                    "scorePerMin": 0,
                    "scorePerMatch": 0,
                    "wins": 0,
                    "top3": 0,
                    "top5": 0,
                    "top6": 0,
                    "top10": 0,
                    "top12": 0,
                    "top25": 3,
                    "kills": 0,
                    "killsPerMin": 0,
                    "killsPerMatch": 0,
                    "deaths": 0,
                    "kd": 0,
                    "matches": 0,
                    "winRate": 0,
                    "minutesPlayed": 0,
                    "playersOutlived": 0,
                    "lastModified": "0"
                },

const currentStats = current_response.data.stats.all.overall;
const initialStats = initial_response.data.stats.all.overall;
const requirements = overallObjectWithChallenge;

let pointsDifference = 0;

if requirements.top25 != 0 {
    
    pointsDifference += 
        (currentStats.wins - initialStats.wins) + 
        (currentStats.top3 - initialStats.top3) +
        (currentStats.top5 - initialStats.top5) +
        (currentStats.top6 - initialStats.top6) +
        (currentStats.top10 - initialStats.top10) +
        (currentStats.top12 - initialStats.top12) +
        (currentStats.top25 - initialStats.top25);
    
    responseForPositiveLogic(requirements.top25, pointsDifference);
        
}

if requirements.top12 != 0 {
    pointsDifference += 
        (currentStats.wins - initialStats.wins) + 
        (currentStats.top3 - initialStats.top3) +
        (currentStats.top5 - initialStats.top5) +
        (currentStats.top6 - initialStats.top6) +
        (currentStats.top10 - initialStats.top10) +
        (currentStats.top12 - initialStats.top12);
    
    responseForPositiveLogic(requirements.top12, pointsDifference);
}

if requirements.top10 != 0 {
    pointsDifference += 
        (currentStats.wins - initialStats.wins) + 
        (currentStats.top3 - initialStats.top3) +
        (currentStats.top5 - initialStats.top5) +
        (currentStats.top6 - initialStats.top6) +
        (currentStats.top10 - initialStats.top10);
    
    responseForPositiveLogic(requirements.top10, pointsDifference);
}

if requirements.top6 != 0 {
    pointsDifference += 
        (currentStats.wins - initialStats.wins) + 
        (currentStats.top3 - initialStats.top3) +
        (currentStats.top5 - initialStats.top5) +
        (currentStats.top6 - initialStats.top6);
    
    responseForPositiveLogic(requirements.top6, pointsDifference);
}

if requirements.top5 != 0 {
    pointsDifference += 
        (currentStats.wins - initialStats.wins) + 
        (currentStats.top3 - initialStats.top3) +
        (currentStats.top5 - initialStats.top5);
    
    responseForPositiveLogic(requirements.top5, pointsDifference);
}

if requirements.top3 != 0 {
    pointsDifference += 
        (currentStats.wins - initialStats.wins) + 
        (currentStats.top3 - initialStats.top3);
    
    responseForPositiveLogic(requirements.top3, pointsDifference);
}

if requirements.wins != 0 {
    pointsDifference += 
        (currentStats.wins - initialStats.wins);
    
    responseForPositiveLogic(requirements.wins, pointsDifference);
}

if requirements.score != 0 {
    pointsDifference += 
        (currentStats.score - initialStats.score);
    
    responseForPositiveLogic(requirements.score, pointsDifference);
}
if requirements.scorePerMin != 0 {
    pointsDifference += 
        (currentStats.scorePerMin - initialStats.scorePerMin);
    
    responseForPositiveLogic(requirements.scorePerMin, pointsDifference);
}
if requirements.scorePerMatch != 0 {
    pointsDifference += 
        (currentStats.scorePerMatch - initialStats.scorePerMatch);
    
    responseForPositiveLogic(requirements.scorePerMatch, pointsDifference);
}
if requirements.kills != 0 {
    pointsDifference += 
        (currentStats.kills - initialStats.kills);
    
    responseForPositiveLogic(requirements.kills, pointsDifference);
}
if requirements.killsPerMin != 0 {
    pointsDifference += 
        (currentStats.killsPerMin - initialStats.killsPerMin);
    
    responseForPositiveLogic(requirements.killsPerMin, pointsDifference);
}

if requirements.killsPerMatch != 0 {
    pointsDifference += 
        (currentStats.killsPerMatch - initialStats.killsPerMatch);
    
    responseForPositiveLogic(requirements.wins, pointsDifference);
}
if requirements.matches != 0 {
    pointsDifference += 
        (currentStats.matches - initialStats.matches);
    
    responseForPositiveLogic(requirements.matches, pointsDifference);
}
if requirements.winRate != 0 {
    pointsDifference += 
        (currentStats.winRate - initialStats.winRate);
    
    responseForPositiveLogic(requirements.winRate, pointsDifference);
}
if requirements.minutesPlayed != 0 {
    pointsDifference += 
        (currentStats.minutesPlayed - initialStats.minutesPlayed);
    
    responseForPositiveLogic(requirements.minutesPlayed, pointsDifference);
}
if requirements.playersOutlived != 0 {
    pointsDifference += 
        (currentStats.playersOutlived - initialStats.playersOutlived);
    
    responseForPositiveLogic(requirements.playersOutlived, pointsDifference);
}

For modularity purposes, the comparison function compares all overall stats variables. It enables the team to introduce new challenges to GamePayy without requiring very specific code.
This facilitates testing, induces less-human error and improves the development cycle.


Update 01/01/23:

Fortnite actually monitors stats as following:
Squad games:
    wins
    top3
    top6

Duo games:
    wins
    top5
    top12

Solo games:
    wins
    top10
    top25

A top10 position, adds 1 to top10 and to top25.


if requirements.top25 != 0 {
    
    pointsDifference += 
        
        (currentStats.top25 - initialStats.top25);
    
    responseForPositiveLogic(requirements.top25, pointsDifference);
        
}

if requirements.top12 != 0 {
    pointsDifference += 
        
        (currentStats.top12 - initialStats.top12);
    
    responseForPositiveLogic(requirements.top12, pointsDifference);
}

if requirements.top10 != 0 {
    pointsDifference += 
        
        (currentStats.top10 - initialStats.top10);
    
    responseForPositiveLogic(requirements.top10, pointsDifference);
}

if requirements.top6 != 0 {
    pointsDifference += 
        
        (currentStats.top6 - initialStats.top6);
    
    responseForPositiveLogic(requirements.top6, pointsDifference);
}

if requirements.top5 != 0 {
    pointsDifference += 
        
        (currentStats.top5 - initialStats.top5);
    
    responseForPositiveLogic(requirements.top5, pointsDifference);
}

if requirements.top3 != 0 {
    pointsDifference += 
        
        (currentStats.top3 - initialStats.top3);
    
    responseForPositiveLogic(requirements.top3, pointsDifference);
}

Which brings us to a much more generic points difference check:

for (key in requirements) {
    if (requirements[key] != undefined){
        if (currentStats[key] - initialStats[key] >= requirements[key]){
            return true;
        }
        return false;
    }
}

I am happy to make those almost 150 lines of code become 7 hehe.